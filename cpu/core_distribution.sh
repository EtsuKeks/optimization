#!/bin/bash

# Анализируем нагрузку процесса с разбивкой по ядрам CPU. Используется утилита pidstat,
# которая мониторит все потоки процесса и их активность. Скрипт суммирует %CPU всех потоков,
# сгруппированных по ID ядра, на котором они исполнялись. Тут важно понимать: pidstat делает
# срез. Он показывает, на каком ядре поток был в момент опроса, но это не такая большая неточность,
# если мы хотим отловить ситуации когда например одно ядро перегружено постоянно.

PID=$1
OUT="./cpu/core_distribution.csv"

# Определяем количество ядер для формирования заголовка CSV
CORES_COUNT=$(grep -c '^processor' /proc/cpuinfo)

# Формируем заголовок: timestamp,cpu0_pct,cpu1_pct,...
HEADER="timestamp"
for ((i=0; i<CORES_COUNT; i++)); do
    HEADER="$HEADER,cpu${i}_pct"
done
echo "$HEADER" > $OUT

# Ставим локаль, чтобы числа точно были с точкой (10.5), а не с запятой
export LC_NUMERIC=C

while kill -0 $PID 2>/dev/null; do
    # sleep 1 здесь не нужен, так как "pidstat 1 1" сам выполняется 1 секунду
    TS=$(date +%s)

    # 2. Запускаем pidstat ровно на 1 секунду (параметры 1 1)
    # -t: показать потоки
    # -p PID: наш процесс
    # 1 1: интервал 1 секунда, количество повторов 1 (чтобы он завершился сам и мы пошли на
    # следующую секунду)
    # Мы сохраняем вывод в переменную, чтобы потом скормить awk
    REPORT=$(pidstat -t -p $PID 1 1)

    # 3. Парсим вывод через awk
    # Мы передаем ему кол-во ядер, чтобы он знал, сколько колонок вывести (даже если нагрузка 0)
    echo "$REPORT" | awk -v ts="$TS" -v cores="$CORES_COUNT" -v out_file="$OUT" '
        # Пропускаем заголовки (строки с Linux, Time, UID и т.д.)
        /^Linux/ || /UID/ || /^$/ || /^Average/ { next }

        {
            # Парсим с конца строки, так надежнее.
            # Пример строки: ... 0.00 12.50 1 command
            # $NF = command
            # $(NF-1) = CPU ID (ядро)
            # $(NF-2) = %CPU
            cpu_id = $(NF-1)
            load = $(NF-2)
            core_sums[cpu_id] += load
        }

        END {
            # Когда весь вывод pidstat прочитан, формируем строку
            printf "%s", ts >> out_file
            for (i=0; i<cores; i++) {
                # Если ядро не встретилось, пишем 0
                val = (i in core_sums) ? core_sums[i] : 0
                printf ",%.2f", val >> out_file
            }
            printf "\n" >> out_file
        }
    '
done